#include <Wire.h>
#include "PID_v1.h"
#include "PinChangeInt.h"
#include "NewPing.h"
#include "LiquidCrystal_I2C.h"

// Robot Mode Constants / Declarations
#define MANUAL    1 // manual mode controller signal
#define AUTO      0 // automatic mode controller signal
int roboMode;       // current mode state

// Ultrasonic Sensor Constants / Declaration
#define RANGEFINDER_TRIGGER_PIN  8
#define RANGEFINDER_ECHO_PIN     A3
#define TEMPERATURE_PIN          A0
#define MAX_DISTANCE             380 // maximum reading distance of ultrasonic sensor in cm

const unsigned int pingSpeed = 50;   // frequency of ping readings in ms. 50ms would be 20 times a second.
unsigned long pingTimer = 0;         // holds the next ping time, in millis()
volatile float echoPulse;            // pulse length returned from ultrasonic sensor
int temperature;                     // ambient temperature in degrees C
float soundTime;                     // intermediate ultrasonic sensor calculation value
float soundVelocity;                 // intermediate ultrasonic sensor calculation value
double distanceCm;                   // calculated distance by ultrasonic sensor in cm
double motorSpeed;                   // speed based on ultrasonic read distance from obstruction
int lastMotorSpeed;                  // variable used to keep track of changes in wall adjustment variable

// Motor Constants / Declarations
#define RIGHT_SPEED_PIN 5
#define RIGHT_DIRECTION_PIN 4
#define LEFT_SPEED_PIN 6
#define LEFT_DIRECTION_PIN 7
#define TURNTHRESH 11                // distance threshold from wall for left turn
#define TURNSPEED 127                // speed of robot's turning function
#define STOPSPEED 0                  // speed value to brake motors
#define TURNTIME 630                 // time in ms it takes for robot to turn 90 degrees at TURNSPEED

int leftSpeed;   // right wheel speed
int rightSpeed;  // left wheel speed

// Motor PID Constants / Declarations
#define motorKp 20                  // PID term: dependent on present error
#define motorKi 5                   // PID term: accumulation of past error
#define motorKd 1                   // PID term: prediction of future error based on current rate of change
double motorSetpoint = 0;           // wall PID Setpoint in degrees, where zero degrees is facing forward
double motorInput;                  // input value for motor PID - delta between encoder counts
double motorOutput = 0;             // adjustment value generated by motor PID      
double lastMotorOutput = 1;         // variable used to keep track of changes in motor adjustment variable

// Encoder and Interrupt Constants / Declarations
volatile unsigned long leftLastTime = 0;  // interrupt timer - for debouncing
volatile unsigned long rightLastTime = 0; // interrupt timer - for debouncing
volatile long leftEncoder = 0;            // left encoder count
volatile long rightEncoder = 0;           // right encoder count

// Manual Mode Constants / Declarations
#define MAX_SPEED 350   // maximum PWM speed
#define FIRST_GEAR 200  // set speed for manual control speed 1
#define SECOND_GEAR 250 // set speed for manual control speed 2
#define THIRD_GEAR 350  // set speed for manual control speed 3
#define TURN_SPEED 200  // set speed for turning while in manual control

// Controller serial commands
const char LEFT = 'L';
const char RIGHT = 'R';
const char CENTRE = 'C';
const char FORWARD = 'F';
const char FORWARD_SPEED_2 = '6';
const char FORWARD_SPEED_1 = '5';
const char STOP = 'S';
const char BACKUP = 'B';

// Testing Declarations / Constants
// NOTE: These are **NOT** Arduino pins, they are only needed to be delcared so we can use the LCD library.
#define I2C_ADDR  0x27 // I2C Address for LCD Display
#define BACKLIGHT_PIN  3
#define EN_PIN  2
#define RW_PIN  1
#define RS_PIN  0
#define D4_PIN  4
#define D5_PIN  5
#define D6_PIN  6
#define D7_PIN  7

unsigned long printTimer = 0; // TODO: comment out to save memory

// object declaration
LiquidCrystal_I2C lcd(I2C_ADDR, EN_PIN, RW_PIN, RS_PIN, D4_PIN, D5_PIN, D6_PIN, D7_PIN);     // Set the LCD I2C address

NewPing sonar(RANGEFINDER_TRIGGER_PIN, RANGEFINDER_ECHO_PIN, MAX_DISTANCE);                 // initialize ultrasonic sensor library
PID motorPID(&motorInput, &motorOutput, &motorSetpoint, motorKp, motorKi, motorKd, DIRECT); // initialize PID to drive robot in a straight line

/*
*------------------------------------------------------------------------------------------
* Setup Function
*------------------------------------------------------------------------------------------
*/
void setup() {
  Serial.begin(9600);                            
  
  // Ultrasound setup
  pinMode(RANGEFINDER_TRIGGER_PIN, OUTPUT);
  pinMode(RANGEFINDER_ECHO_PIN, INPUT);
  pinMode(TEMPERATURE_PIN, INPUT);
  
  temperature = (500 * analogRead(TEMPERATURE_PIN)) >> 10; // ambient temperature reading
  soundVelocity = (331.3 + (0.6 * temperature));           // speed of sound with temperature adjustment
  
  // Motor PinSetup
  pinMode(RIGHT_SPEED_PIN, OUTPUT);
  pinMode(RIGHT_DIRECTION_PIN, OUTPUT);
  pinMode(LEFT_SPEED_PIN, OUTPUT);
  pinMode(LEFT_DIRECTION_PIN, OUTPUT);
 
  // Motor PID controller setup
  motorPID.SetOutputLimits(-127, 127);
  motorPID.SetMode(AUTOMATIC); // pid is driving, to start
  motorPID.SetSampleTime(20); // Recalculate PID every x ms, no more

  // LCD initialization
  lcd.begin(16, 2);
  lcd.home();
  lcd.clear();
  lcd.setBacklightPin(BACKLIGHT_PIN, POSITIVE);
  lcd.setBacklight(HIGH);

  // Begin Interrupt Counts
  attachInterrupt(0, rightISR, CHANGE);  //init hardware interrupt 0 for digital pin 2 
  attachPinChangeInterrupt(11, leftISR, CHANGE); // intialize software interrupt - motor noise caused problems with hardware interrupt 1
  
  bluetoothInit(); // wait to pair  robot Bluetooth with controller
}

/*
*------------------------------------------------------------------------------------------
* Bluetooth Controller Pairing
*------------------------------------------------------------------------------------------
*/
void bluetoothInit() {
  while (1) { // executes until controller message is detected
    if (Serial.available() > 0) {
      Serial.println("!"); // reply to controller
      Serial.flush(); // clear serial buffer for future commands
      break;
    }
  }
}

/*
*------------------------------------------------------------------------------------------
* Interrupt service routine for left wheel encoder
*------------------------------------------------------------------------------------------
*/
void leftISR() {
  if ( (millis() - leftLastTime) >= 10 ) {
    leftLastTime = millis();
    leftEncoder++;  //count left wheel encoder interrupts
  }
}

/*
*------------------------------------------------------------------------------------------
* Interrupt service routine for right wheel encoder
*------------------------------------------------------------------------------------------
*/
void rightISR() {
  if ( (millis() - rightLastTime) >= 10 ) {
    rightLastTime = millis();
    rightEncoder++; //count right wheel encoder interrupts
  }
}

/*
*------------------------------------------------------------------------------------------
* Main Loop Function
*------------------------------------------------------------------------------------------
*/
void loop() {
  if (roboMode == AUTO) {
    automaticDrivingMode();
  } else { // full manual mode using controller
    while (Serial.available() > 0) {
      char heading = Serial.read();
      manualDrivingMode(heading);
    }
  }
}

/*
*------------------------------------------------------------------------------------------
* Initiates sonar pin where ping_timer activates interrupt service routine 
*------------------------------------------------------------------------------------------
*/
void readUltrasonic() {
  if (millis() >= pingTimer) {   // if it has been pingSpeed milliseconds since last ping, do another ping.
    pingTimer += pingSpeed;      // set next ping time.
    sonar.ping_timer(echoCheckISR); // check for ping every 20us
  }
}

/*
*------------------------------------------------------------------------------------------
* Driving commands for automatic mode
*------------------------------------------------------------------------------------------
*/
void automaticDrivingMode() {
  readUltrasonic(); // record ultrasonic distance to obstruction

  motorSpeed = map(distanceCm, 3, 200, 50, 300); // maps speed correction factor from distance scaling to velocity scaling
  
  // --------PID CONTROL CASE EXAMPLE--------    
  // When the encoder difference goes POSITIVE, the right wheel is moving faster.
  // So with DIRECT control, the output will go NEGATIVE to try and control it.
  // Since output is NEGATIVE, we should SUBTRACT it from the leftSpeed to make the left wheel catch up,
  // and ADD output to rightSpeed to slow the right wheel down.
  
  motorInput = rightEncoder - leftEncoder; // correction delta   
  motorPID.Compute(); // updates motor PID output
  
  // adjust wheel speeds based on PID and ultrasonic correction factors
  boolean motorOutputChanged = (motorOutput != lastMotorOutput);
  boolean motorSpeedChanged = (motorSpeed != lastMotorSpeed);
  
  if (motorOutputChanged || motorSpeedChanged) {
    leftSpeed = motorSpeed - motorOutput;           
    rightSpeed = motorSpeed + motorOutput;          
    
    travel(leftSpeed, rightSpeed); // drive towards wall at calculated speed
    demoLCD(1); // print forward information to LCD
    
    lastMotorOutput = motorOutput;
    lastMotorSpeed = motorSpeed;
  }
  
  // turn left when near approaching object
  if ((distanceCm < TURNTHRESH) && (distanceCm != 0)) {
    turnLeftAuto();
    
    int waitTime = millis();
    while (millis() < (waitTime + 1000)) {
      readUltrasonic();
    }
    
  } 
}

/*
*------------------------------------------------------------------------------------------
* Driving commands for manual mode
*------------------------------------------------------------------------------------------
*/
void manualDrivingMode(char heading) {
  if (heading == LEFT)
    turnLeftManual(TURN_SPEED, TURN_SPEED);
  else if (heading == RIGHT)
    turnRightManual(TURN_SPEED, TURN_SPEED);
  else if (heading == CENTRE)
    travel(FIRST_GEAR, FIRST_GEAR);
  else if (heading == FORWARD)
    travel(FIRST_GEAR, FIRST_GEAR);
  else if (heading == FORWARD_SPEED_1)
    travel(SECOND_GEAR, SECOND_GEAR);
  else if (heading == FORWARD_SPEED_2)
    travel(THIRD_GEAR, THIRD_GEAR);
  else if (heading == BACKUP)
    travel(FIRST_GEAR * (-1), FIRST_GEAR * (-1));  
  else if (heading == STOP)
    brake();
}

/*
*------------------------------------------------------------------------------------------
* Motor Control Functions
*
* Controls the motors given a speed until a certain distance this version of motorControl()
* has both motors running at different speeds to help make the robot go straight
*------------------------------------------------------------------------------------------
*/

/*
*------------------------------------------------------------------------------------------
* Drives robot forward / backward for given parameter speed values
*------------------------------------------------------------------------------------------
*/
void travel(int leftMotor, int rightMotor) {
  if (rightMotor >= 0) {
    analogWrite (RIGHT_SPEED_PIN, rightMotor); //PWM Speed Control (0-255)
    digitalWrite(RIGHT_DIRECTION_PIN, LOW); // LOW = moves forwards
  } else {
    analogWrite (RIGHT_SPEED_PIN, abs(rightMotor)); //PWM Speed Control (0-255)
    digitalWrite(RIGHT_DIRECTION_PIN, HIGH); // HIGH = moves backward
  }
  
  if (leftMotor >= 0) {
    analogWrite (LEFT_SPEED_PIN, leftMotor); //PWM Speed Control (0-255)
    digitalWrite(LEFT_DIRECTION_PIN, LOW);  // LOW = moves forwards
  } else {
    analogWrite (LEFT_SPEED_PIN, abs(leftMotor)); //PWM Speed Control (0-255)
    digitalWrite(LEFT_DIRECTION_PIN, HIGH);  // HIGH = moves backward
  }
}

/*
*------------------------------------------------------------------------------------------
* Stops both motors
*------------------------------------------------------------------------------------------
*/
void brake() {
  digitalWrite(RIGHT_DIRECTION_PIN, HIGH); //brake right wheel
  digitalWrite(LEFT_DIRECTION_PIN, HIGH); //brake left wheel
  analogWrite (RIGHT_SPEED_PIN, 0); //PWM Speed Control
  analogWrite (LEFT_SPEED_PIN, 0); //PWM Speed Control
}

/*
*------------------------------------------------------------------------------------------
* Robot turns left ninety degrees for automatic mode
*------------------------------------------------------------------------------------------
*/
void turnLeftAuto() {
  demoLCD(0); // print turning information to LCD
  
  // right wheel forward
  analogWrite (RIGHT_SPEED_PIN, TURNSPEED); //PWM Speed Control (0-255)
  digitalWrite(RIGHT_DIRECTION_PIN, LOW); // LOW = moves forwards
 
  // left goes backward 
  analogWrite (LEFT_SPEED_PIN, TURNSPEED); //PWM Speed Control (0-255)
  digitalWrite(LEFT_DIRECTION_PIN, HIGH);  // HIGH = moves backward
   
  delay(TURNTIME);
 
  brake(); // stops wheels
}

/*
*------------------------------------------------------------------------------------------
* Robot turns right degrees for manual mode
*------------------------------------------------------------------------------------------
*/
void turnRightManual(int left, int right) {
  digitalWrite(RIGHT_DIRECTION_PIN, HIGH); //right wheel moves backwards
  digitalWrite(LEFT_DIRECTION_PIN, LOW); //left wheel moves forwards, should be HIGH but reads value wrong
  analogWrite (RIGHT_SPEED_PIN, right * 51 / 80); //PWM Speed Control
  analogWrite (LEFT_SPEED_PIN, left * 51 / 80); //PWM Speed Control
}

/*
*------------------------------------------------------------------------------------------
* Robot turns left degrees for manual mode
*------------------------------------------------------------------------------------------
*/
void turnLeftManual(int left, int right) {
  digitalWrite(RIGHT_DIRECTION_PIN, LOW); //right wheel moves forwards
  digitalWrite(LEFT_DIRECTION_PIN, HIGH); //left wheel moves backwards, should be LOW but reads value wrong
  analogWrite (RIGHT_SPEED_PIN, right * 51 / 80); //PWM Speed Control
  analogWrite (LEFT_SPEED_PIN, left * 51 / 80); //PWM Speed Control
}

/*
*------------------------------------------------------------------------------------------
* Timer2 interrupt calls this function every 24uS to check ultrasonic ping status
* From https://code.google.com/p/arduino-new-ping/wiki/Ping_Event_Timer_Sketch
*------------------------------------------------------------------------------------------
*/
void echoCheckISR() {
  if (sonar.check_timer()) { // This is how you check to see if the ping was received.  
    echoPulse = float(sonar.ping_result); // returns time to and from object
    soundTime = echoPulse / 2; // divide by two because functions returns time too and from obstruction
    distanceCm = (soundVelocity * soundTime) / 10000; // distance = velocity * time
  }
}
 
/*
*------------------------------------------------------------------------------------------
* Creates a string out of motor direction and speed
* to send to the controller via bluetooth for automatic mode
*------------------------------------------------------------------------------------------
*/
void createAutoBluetoothMessage(int mode, int vel) {
  String message;

  if (mode = 0) { // forward
    message = String(mode) + "," + String(vel);
  } else { // turn left
    message = String(mode);
  }
  
  Serial.print(message); // sends message to controller via bluetooth
}

/*
*------------------------------------------------------------------------------------------
* Prints fancy LCD messages
*------------------------------------------------------------------------------------------
*/ 
void demoLCD(int dir) { // 1 forward, 0 left
  if ((printTimer + 200) > millis()) { // delay print for readability
    lcd.clear();
    
    if (dir == 1) {
      lcd.setCursor(0,0);
      lcd.print("*****FORWARD****");
      lcd.setCursor(0,1);
      lcd.print("     " + String(rightSpeed));
    } else {
      lcd.setCursor(0,0);
      lcd.print("//////LEFT//////");
      lcd.setCursor(0,1);
      lcd.print("////////////////");
      
      printTimer = millis();
    }
  }
}

/*
*------------------------------------------------------------------------------------------
* Serial monitor troubleshooting printout
*------------------------------------------------------------------------------------------
*/ 
void testSerialPrint() {
  if ( (printTimer + 100) < millis() ) { // delay print for readability
    // Motor serial prints for testing    
    Serial.print("Encoders: ");
    Serial.print(leftEncoder);
    Serial.print(" ");
    Serial.print(rightEncoder);
    Serial.print("       Speeds: ");
    Serial.print(leftSpeed);
    Serial.print(" ");
    Serial.print(rightSpeed);
    Serial.print("       Heading: ");
    Serial.println(motorSetpoint);
  
    //Sonar serial prints for testing
    Serial.print("Distance: ");
    Serial.print(distanceCm);
    Serial.print(" cm Motorspeed: ");
    Serial.println(motorSpeed);
    printTimer = millis();
  }
}
  
/*
*------------------------------------------------------------------------------------------
* LCD troubleshooting printout
*------------------------------------------------------------------------------------------
*/ 
void testLCD(int rightSpeed, int leftSpeed, int rightEncoder, int leftEncoder) {
  if ( (printTimer + 200) < millis() ) { // delay print for readability
    lcd.clear();
  
    lcd.leftToRight();
    lcd.setCursor(0, 0);
    lcd.print("L: ");
  
    lcd.rightToLeft();
    lcd.setCursor(6, 0);
    lcd.print(leftSpeed);
    lcd.setCursor(16, 0);
    lcd.print(leftEncoder);
  
    lcd.leftToRight();
    lcd.setCursor(0, 1);
    lcd.print("R: ");
  
    lcd.rightToLeft();
    lcd.setCursor(6, 1);
    lcd.print(rightSpeed);
    lcd.setCursor(16, 1);
    lcd.print(rightEncoder);
    printTimer = millis();
  }
}
