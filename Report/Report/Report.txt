EECE 281 Section 202
Project 1
Lab section: L2D
Group #: L2D_7A, L2D_7B
Group’s Lab-Bench #s: 7A and 7B

Student names, numbers and contribution percentages:    
Name				Student ID		Contribution Percentage
Diksha Bansal		 45000122
Anthony Chui		
John Deppe			
Logan Gilmore		
Theresa Mammarella	45578127	
Steven Olsen		

This document serves as a complete documentation of the circuitry and functionality of the project. The project report should have sufficient detail that someone skilled in the art could reproduce or improve upon your results. Include component numbers and info, values, block diagrams, schematics, overall and detailed explanation, comments, … when necessary.
You may only include code segments in the report whenever needed for explanations. As usual you will need to submit the complete code file separately, and also to include the complete code as an appendix to this report. The code must include sufficient comments for documentation.
The number of pages for the report should be less than 10 (not including appendices), double (or 1.5) spaced, ‘Arial’ or ‘Times New Roman’ font size 11 for text, and ‘Courier New’ font size 8 or 10 for the source code, approximately one inch margin for the top, bottom, left, and right margins. It should include the following sections.
It should include the course name and number, lab section, group and bench numbers, project name, student names, and student numbers. The title page should also include an estimated percentage of participation of each group member in the project.


Table of Contents
------------------------
1. Contributions
2. Introduction and motivations
3. Project Description
4. Conclusions
5. References and bibliography
6. Appendix A
7. Appendix B


Contributions
------------------
List and explain the contribution percentage of each team member, as well as the description of the task(s) each member worked on and completed. The sum of the individual percentages must add up to 100%. Ideally, group members should have equal participation in the project.
This estimate declaration (among other assessing points for contribution) will be used to scale the project mark to each group member. For example, assume that the estimated percentage is: Pedro 30%, John 20%, and Nancy 50% for a three-person group and the project mark is 14 out of 20, the marks will be Pedro =0.30*(14*3) = 12.6, John =0.20*(14*3) = 8.4, and Nancy=0.50*(14*3) = 20 (The mark caps at the max project grade).


Introduction and motivations
--------------------------------------
In this project, we were asked to build a marketable autonomous robot that is at the very least, capable of moving straightforward at its maximum speed until it detects an object, and then decelerates gradually. It should get as close as possible to the object without hitting it. 

The remote controlled cars available in the market was our inspiration. With everything becoming wireless these days, we decided to use Bluetooth to connect the robot to the hand  held controller.  
(Include design objective and specifications. 
Also Include the list and description of the files submitted for this lab (including code and Fritzing breadboard schematics))


Project Description 
--------------------------
This section is the main part of your project report and should have sub-headings.
Include summary of each part of and the complete lab experiment. Overview of the overall design approach including system block diagrams for both the hardware and software designs. 
Explain the design, and implementation procedures. During the lab if you selected a method over the others for any step, describe the second best alternative you considered.
Explain the evaluation/testing procedure and results. Include the problems you encounter and how to resolve them, as well as best practices you learned.

--Planning and Preliminary steps--
This was our first project to use all six team members in collaboration.  Recognizing that this might present organizational challenges, we spent a large portion of our first meetup planning our robot's design, as well as a timeline for the project.

This was helpful to get the team thinking on the same page, however we learned so much about the Arduino and other components of the robot that many of our design decisions changed considerably from the initial design.

One of the most effective strategies we came up with during this meeting was to keep a common pin map document on GitHub for each of our Arduinos.

--Motors--
One of our priorities was to get the motors working, as we havn't worked with them before.
Steve and John op-tested the motors, put 36V across one, found smoke! Turns out the motors are limited to 6V.

Another priority was getting to know the motor shield really well, studied the data sheets extensively.
Steve figured out we could read the voltage across each motor from one of the pins on the motor shield chip, which we wanted to factor into speed calculations.  Pin broke off the chip and best up the board :( got a new shield with voltage sensing pins already built in.

--Power Supply--
Another priority was figuring out the best way to power the robot.

Decided to use one power source to power both the arduino board and the motors instead of two.  The arduino has built in device for reducing noise generated by the batteries.  We also added small capacitors parallel to the batteries to help with this.
After initially assembling the robot, threw the switch and quickly found smoke! Shut it off, had a bit of a panic, fearing we blew a motor, found out the power switch was wired wrong and was shorting the batteries.  Battery pack was fried.

Eventually we decided to use two power supplies instead..
Talk about noise from the motors and putting on capacitors.


--Controller--
As a second functionality, we decided to build a remote controller for the robot.

The controller would have an accelerometer and gyroscope attatched to it so that it could detect thrust and tilt and send
a signal to the robot appropriately. For the bulk of our commands, which is turning, we decided to use the gyroscope 
to determine the direction of our robot. Essentially, tilting the controller left, for example, will cause the robot to turn left as long
as the left position is held. In order to maintain the state of our controller, we needed to keep track of the degrees
of the controller. Wherever the controller is held at initialization, is where the center is defined (0 degrees). 

One particular problem with obtaining degrees turned is the fact that the gyroscope, of course, returns data in degrees
per second. To get degrees, the data must be integrated with respect to time. Since there is no function that 
models random, real data, we use a form of approximate integration to obtain total degrees turned. By simply summing up
(degrees per second * read delay duration), a close reading of degrees can reliably be achieved. We use this degrees value
to determine whether the state is in the left, center or right boundary (i.e -20 to 20 degrees is defined as the center). 

However, errors will begin to build up in the angle summation and eventually the center line will be misaligned. Using the 
accelerometer to compute the angle as well was the solution to this. Using 3D trigonometry and the projection of the gravity 
vector onto the axises, another angle of rotation is achieved. This one is reliable in the long term as opposed to the
gyroscope integration requirements, since it recalculates its angle from acceleration each time rather than summing up previous
measurements. 

Combining both the gyroscope and accelerometer angle measurements into what's known as a complimentary filter essentially takes
the best of both worlds. Although the measurements may not always record a perfect 90 when its physically tilted as such, the 
fact that the angle readings are consistent independent of speed or time, makes this design choice the best method to record
the angle of rotation. Ultimately, the design of our controller is very responsive, and is rather similar to the likes
of a Wii-Mote. 

Our theme for the project was Pacman, and since the robot is a ghost we wanted to stick to the theme and made the controller into Pacman himself.  Being a spherical shape, we decided mounting the hardware inside of a hamster ball would be the best option in terms of easily accessing the components and protecting the components.

The first step was to mount the ball in half with an exacto knife.
We fixed the metal sensor mount that came with the robot kit inside the ball.  The arduino was screwed on facing towards the center.  The battery is on the other side of the sensor mount and positioned in such a way that the hamster port can be unscrewed for easy access to take out the battery.  One issue we ran into was not having enough room to fit the usb cable in for uploading/ testing code.  We fixed this by cutting a whole in the side of the ball.
To make sure there were as few controller parts as possible, all our components are neatly soldered on to the arduino prototyping shield including bluetooth master, piezo buzzers, voltage divider for lcd, accelerometer/ gyroscope..


We mounted the LCD display on the upper half of the hamster ball.  since the ball is see through it is easy to see what is displayed with the backlight on.  We decided against cutting a hole for it so the LCD screen would be better protected from drops.  Also combined lcd wires to combine common grounds to make for less of a hassle of wires inside the controller.

--Encoder--
About a week into the process, we realized the car wouldnt go straight because of motor discrepencies.  Tried to use a magic number but the problem wasnt consistent (include picture of testing).  Decided the best solution would be to build an encoder.
more about encoders..

--Additional Functionalities and Considerations--
-Double Arduino-
During our initial planning we wanted to use two of our three arduinos on the robot to utilize its extra pin space.  After researching the master-slave relationship ect, we decided using an extra arduino just for the sake of extra pins was not a very good reason, and adjusted the design accordingly.

-LCD I2C adapter-
One of the ways we decreased pin usage was finding an adapter that reduced the 8 pins used by the lcd display to two serial pins.  We attached the lcd to the adapter by soldering each of them to a common piece of prototyping bored.  Elaborate on coding ect..

-Temperature and Humidity sensor-
decided to mount the temp/ humidity sensor to the board so we could factor in both humidity and temperature into our speed of sound calculations to increase the acccuracy of the distance calculations from the ultrasonic sensor.  Concluded that an excessive use of constants (ie heat capacities with limited accuracy would probably end up making little difference in the speed of sound calculation, 0.1 to 0.6% as read, or potentially worsen the results.  Went back to only using the room's temperature.  (For another reason, the blue sensor is a bit farther away from the board than the little lm35 guy would be therefore less likely to pick up heat from other components?)

-double piezo buzzers-
To go along with the theme we wanted use two piezo buzzers to play an elaborate pacman theme song (bass/ melody line).  Figured out the standard Arduino tone library uses PWM Timer1 exclusively.  It changes square wave frequencies by directly changing the frequency of the timer, and could therefore not play two at once.  Decided to change frequencies ourselves.. considerations about not putting it on robot for interfering with motors.

-collision sensor-
Decided to use a collision sensor to detect if the robot ran into anything.  Justified this decision becasue of ultrasonic interference during lab time.  Got collision sensor component that reads high when triggered, has a built in potentiometer to adjust the trigger threshold.  After writing code to test and mounting to the arduino we discovered that the sensor was too sensitive for our purposes as it was triggered on the acceleration/ deceleration of the wheels. Considered using current spikes read from the motor shield as indication of collisions.

Conclusions
-----------------
After blowing up some components, writing pieces of code, and testing continuously, we were able to build a robot with the desired specifications along with extra functionality. 


References and bibliography
--------------------------------------


Appendix A
----------------
Include the complete Arduino code (the pages that are used for this appendix are not counted towards the report length.) 


Appendix B
----------------
Include any other relevant info that does not fit in any other section in the report (the pages that are used for this appendix are not counted towards the report length.)
